#!/bin/bash

# Git worktree management script
# Stores worktrees in <configurable-base>/<project-name>/<branch-name>
# Base path can be configured via git config worktree.basepath or $GIT_WT_BASE

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Validate and sanitize a path for use as worktree base
validate_worktree_path() {
    local path="$1"
    local source="$2"  # For error messages: "local config", "global config", "environment variable"

    # Expand tilde
    path="${path/#\~/$HOME}"

    # Check for dangerous characters including control characters and newlines
    if [[ "$path" =~ [\;|&\$\`[:cntrl:]] ]]; then
        warning "Invalid path in $source: contains dangerous characters"
        warning "Path should not contain: ; | & \$ \` or control characters"
        return 1
    fi

    # Check if path is absolute
    if [[ "$path" != /* ]]; then
        warning "Invalid path in $source: must be an absolute path"
        warning "Got: $path"
        warning "Expected path starting with /"
        return 1
    fi

    # Normalize path by removing trailing slashes
    path="${path%/}"

    # Canonicalize the path to resolve '..' and prevent path traversal
    # Use -m to allow non-existent paths (won't create them)
    if command -v realpath &> /dev/null; then
        path=$(realpath -m "$path" 2>/dev/null)
        if [[ $? -ne 0 ]]; then
            warning "Invalid path in $source: could not canonicalize path"
            return 1
        fi
    else
        # Fallback: warn user that realpath is not available
        # Basic path normalization - remove trailing slashes and collapse multiple slashes
        warning "realpath command not found - path traversal protection is limited"
        warning "Install 'realpath' for better security (brew install coreutils on macOS)"
        # Basic normalization: collapse multiple slashes and remove trailing slash
        path=$(echo "$path" | sed 's#/\+#/#g' | sed 's#/$##')
    fi

    echo "$path"
    return 0
}

# Get base directory for all worktrees
# Priority: local git config > global git config > environment variable > default
get_worktree_base() {
    local base_path
    local validated_path

    # Try local git config first
    base_path=$(git config --local --get worktree.basepath 2>/dev/null)
    if [[ -n "$base_path" ]]; then
        validated_path=$(validate_worktree_path "$base_path" "local git config")
        if [[ $? -eq 0 ]]; then
            echo "$validated_path"
            return
        fi
        # Invalid config - fall through to next option
        warning "Falling back to next configuration option..."
        echo "" >&2  # Add blank line for readability
    fi

    # Try global git config
    base_path=$(git config --global --get worktree.basepath 2>/dev/null)
    if [[ -n "$base_path" ]]; then
        validated_path=$(validate_worktree_path "$base_path" "global git config")
        if [[ $? -eq 0 ]]; then
            echo "$validated_path"
            return
        fi
        # Invalid config - fall through to next option
        warning "Falling back to next configuration option..."
        echo "" >&2  # Add blank line for readability
    fi

    # Try environment variable
    if [[ -n "$GIT_WT_BASE" ]]; then
        validated_path=$(validate_worktree_path "$GIT_WT_BASE" "environment variable GIT_WT_BASE")
        if [[ $? -eq 0 ]]; then
            echo "$validated_path"
            return
        fi
        # Invalid config - fall through to default
        warning "Falling back to default path..."
        echo "" >&2  # Add blank line for readability
    fi

    # Default
    echo "$HOME/Git/.worktrees"
}

# Base directory for all worktrees
WORKTREE_BASE=$(get_worktree_base)

# Check for worktrees in different locations and warn about migration
check_worktree_migration() {
    local project_name=$(get_project_name 2>/dev/null)

    # Only check if we can get the project name (we're in a git repo)
    if [[ -z "$project_name" ]]; then
        return
    fi

    local current_base="$WORKTREE_BASE"
    local found_elsewhere=false
    local other_locations=()

    # Check all possible configuration sources for different paths
    local local_config=$(git config --local --get worktree.basepath 2>/dev/null)
    local global_config=$(git config --global --get worktree.basepath 2>/dev/null)
    local env_var="$GIT_WT_BASE"
    local default_path="$HOME/Git/.worktrees"

    # Build list of paths to check (excluding the current one)
    # Expand tildes and deduplicate paths
    local paths_to_check=()
    local seen_paths=()

    # Helper to add path if unique and different from current
    add_if_unique() {
        local path="$1"
        # Only expand tilde if path isn't already absolute (avoid double expansion)
        if [[ "$path" == "~"* ]]; then
            path="${path/#\~/$HOME}"
        fi

        # Skip if it's the current base (which is already expanded)
        if [[ "$path" == "$current_base" ]]; then
            return
        fi

        # Check if already seen (safe for empty array)
        local seen_path
        for seen_path in "${seen_paths[@]}"; do
            if [[ "$seen_path" == "$path" ]]; then
                return
            fi
        done

        # Add to both arrays
        paths_to_check+=("$path")
        seen_paths+=("$path")
    }

    [[ -n "$local_config" ]] && add_if_unique "$local_config"
    [[ -n "$global_config" ]] && add_if_unique "$global_config"
    [[ -n "$env_var" ]] && add_if_unique "$env_var"
    add_if_unique "$default_path"

    # Check if worktrees exist in other locations
    for check_path in "${paths_to_check[@]}"; do
        local project_dir="$check_path/$project_name"
        if [[ -d "$project_dir" ]] && [[ -n "$(ls -A "$project_dir" 2>/dev/null)" ]]; then
            found_elsewhere=true
            other_locations+=("$project_dir")
        fi
    done

    # Show migration warning if worktrees found elsewhere
    if [[ "$found_elsewhere" == "true" ]]; then
        echo "" >&2
        warning "Migration Notice: Existing worktrees found in different location(s):"
        for location in "${other_locations[@]}"; do
            echo -e "  ${YELLOW}•${NC} $location" >&2
        done
        echo "" >&2
        info "Current worktree base: $current_base" >&2
        info "Existing worktrees in the old location(s) won't be detected by git-wt." >&2
        info "You may want to move them to the new location or adjust your configuration." >&2
        echo "" >&2
    fi
}

# Print colored messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

success() {
    echo -e "${GREEN}$1${NC}"
}

info() {
    echo -e "${BLUE}$1${NC}"
}

warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not a git repository"
        exit 1
    fi
}

# Get the project name from git repo
get_project_name() {
    # Try to get from remote URL first
    local remote_url
    remote_url=$(git config --get remote.origin.url 2>/dev/null)

    local project_name
    if [[ -n "$remote_url" ]]; then
        # Extract project name from URL (handles both SSH and HTTPS)
        project_name=$(echo "$remote_url" | sed -E 's/.*[:/]([^/]+)\/([^/]+)(\.git)?$/\2/' | sed 's/\.git$//')
    else
        # Fallback to directory name
        project_name=$(basename "$(git rev-parse --show-toplevel)")
    fi

    echo "$project_name"
}

# Get the main worktree path
get_main_worktree() {
    git worktree list | head -n 1 | awk '{print $1}'
}

# Detect package manager
detect_package_manager() {
    local worktree_path="$1"

    if [[ -f "$worktree_path/pnpm-lock.yaml" ]]; then
        echo "pnpm"
    elif [[ -f "$worktree_path/yarn.lock" ]]; then
        echo "yarn"
    elif [[ -f "$worktree_path/package-lock.json" ]]; then
        echo "npm"
    else
        # Default to pnpm if no lock file found but package.json exists
        if [[ -f "$worktree_path/package.json" ]]; then
            echo "pnpm"
        else
            echo ""
        fi
    fi
}

# Symlink env files
symlink_env_files() {
    local source_dir="$1"
    local target_dir="$2"

    local env_files
    env_files=$(find "$source_dir" -maxdepth 1 -type f \( -name ".env" -o -name ".env.*" \) 2>/dev/null)

    if [[ -z "$env_files" ]]; then
        info "No .env files found to symlink"
        return
    fi

    info "Symlinking .env files..."
    while IFS= read -r env_file; do
        if [[ -n "$env_file" ]]; then
            local filename
            filename=$(basename "$env_file")
            local target="$target_dir/$filename"

            if [[ -e "$target" ]]; then
                warning "Skipping $filename (already exists in worktree)"
            else
                ln -s "$env_file" "$target"
                success "  Linked $filename"
            fi
        fi
    done <<< "$env_files"
}

# Check if fzf is installed
check_fzf() {
    if ! command -v fzf &> /dev/null; then
        error "fzf is required for interactive mode"
        echo ""
        info "Install fzf:"
        echo "  macOS:  brew install fzf"
        echo "  Linux:  apt install fzf  (or your package manager)"
        echo ""
        info "Alternatively, use direct mode:"
        echo "  git-wt <branch-name>"
        echo "  git-wt --list"
        exit 1
    fi
}

# Check if branch has a worktree
has_worktree() {
    local branch="$1"
    local project_name
    project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch"
    [[ -d "$worktree_path" ]]
}

# Get worktree path for branch
get_worktree_path() {
    local branch="$1"
    local project_name
    project_name=$(get_project_name)
    echo "$WORKTREE_BASE/$project_name/$branch"
}

# Generate branch list with indicators for fuzzy finder
# Parameters:
#   $1: mode - "local-only" to only show local branches, "all" to show all branches
generate_branch_list() {
    local mode="${1:-all}"
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null || echo "")

    # Get branches based on mode
    local branches=()

    # Local branches
    while IFS= read -r branch; do
        branches+=("$branch|local")
    done < <(git branch --format='%(refname:short)' 2>/dev/null)

    # Remote branches (excluding HEAD) - only if mode is "all"
    if [[ "$mode" == "all" ]]; then
        while IFS= read -r branch; do
            local branch_name="${branch#origin/}"
            # Skip if this is HEAD or if we already have it as local
            # Check if branch already exists in array with "|local" suffix using literal string match
            if [[ "$branch_name" != "HEAD" ]] && ! [[ " ${branches[*]} " == *" $branch_name|local "* ]]; then
                branches+=("$branch_name|remote")
            fi
        done < <(git branch -r --format='%(refname:short)' 2>/dev/null | grep "^origin/")
    fi

    # Sort and format branches with indicators
    local formatted_branches=()

    # First add current branch
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" == "$current_branch" ]]; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    # Then add branches with worktrees
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" != "$current_branch" ]] && has_worktree "$branch"; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    # Then add other local branches
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" != "$current_branch" ]] && ! has_worktree "$branch" && [[ "$type" == "local" ]]; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    # Finally add remote-only branches
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" != "$current_branch" ]] && ! has_worktree "$branch" && [[ "$type" == "remote" ]]; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    printf '%s\n' "${formatted_branches[@]}"
}

# Format a single branch line with indicators
format_branch_line() {
    local branch="$1"
    local type="$2"
    local current_branch="$3"

    local indicator=""
    local suffix=""

    # Add worktree indicator
    if has_worktree "$branch"; then
        indicator="\033[0;32m✓\033[0m "  # Green checkmark
    else
        indicator="  "
    fi

    # Add status suffix
    if [[ "$branch" == "$current_branch" ]]; then
        suffix=" \033[0;33m[current]\033[0m"  # Yellow
    elif [[ "$type" == "remote" ]]; then
        suffix=" \033[0;36m[remote only]\033[0m"  # Cyan
    fi

    echo -e "${indicator}${branch}${suffix}"
}

# Show worktree info for preview pane
show_worktree_info() {
    local line="$1"

    # Strip ANSI color codes and extract branch name
    local branch
    branch=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^[✓ ]*//' | sed 's/ \[.*\]$//')

    if [[ -z "$branch" ]]; then
        echo "No branch selected"
        return
    fi

    echo "Branch: $branch"
    echo ""

    # Check if worktree exists
    local worktree_path
    worktree_path=$(get_worktree_path "$branch")

    if [[ -d "$worktree_path" ]]; then
        echo "Worktree: $worktree_path"

        # Git status
        cd "$worktree_path" 2>/dev/null || return
        local status
        status=$(git status --porcelain 2>/dev/null)
        if [[ -z "$status" ]]; then
            echo "Status: Clean ✓"
        else
            echo "Status: Has uncommitted changes"
        fi

        # Last modified time
        local last_modified
        # Detect platform and use appropriate stat command
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS uses -f flag
            last_modified=$(find "$worktree_path" -type f -not -path "*/node_modules/*" -not -path "*/.git/*" -exec stat -f "%m %N" {} \; 2>/dev/null | sort -rn | head -1 | awk '{print $1}')
        else
            # Linux uses -c flag
            last_modified=$(find "$worktree_path" -type f -not -path "*/node_modules/*" -not -path "*/.git/*" -exec stat -c "%Y %n" {} \; 2>/dev/null | sort -rn | head -1 | awk '{print $1}')
        fi
        if [[ -n "$last_modified" ]]; then
            local mod_date
            mod_date=$(date -r "$last_modified" "+%Y-%m-%d %H:%M" 2>/dev/null)
            echo "Last modified: $mod_date"
        fi

        # Directory size
        local total_size
        total_size=$(du -sh "$worktree_path" 2>/dev/null | awk '{print $1}')
        echo "Size: $total_size"

        if [[ -d "$worktree_path/node_modules" ]]; then
            local nm_size
            nm_size=$(du -sh "$worktree_path/node_modules" 2>/dev/null | awk '{print $1}')
            echo "  (node_modules: $nm_size)"
        fi

        echo ""
        echo "Recent commits:"
        git log --oneline --color=always -n 3 2>/dev/null | sed 's/^/  /'

    else
        echo "Worktree: Not created"
        echo ""

        # Check if branch exists locally or remotely
        if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            echo "Branch type: Local"
            echo ""
            echo "Recent commits:"
            git log --oneline --color=always -n 3 "$branch" 2>/dev/null | sed 's/^/  /' || echo "  No commits yet"
        elif git ls-remote --heads origin "$branch" 2>/dev/null | grep -q "$branch"; then
            echo "Branch type: Remote only (origin/$branch)"
            echo ""
            echo "Recent commits:"
            git log --oneline --color=always -n 3 "origin/$branch" 2>/dev/null | sed 's/^/  /' || echo "  Unable to fetch commits"
        else
            # New branch - show what it will be created from
            local current_branch
            current_branch=$(git branch --show-current 2>/dev/null)
            if [[ -n "$current_branch" ]]; then
                echo "Branch type: New (will be created from '$current_branch')"
            else
                # Detached HEAD - show commit hash
                local commit_hash
                commit_hash=$(git rev-parse --short HEAD 2>/dev/null)
                echo "Branch type: New (will be created from commit $commit_hash)"
            fi
        fi
    fi
}

# Check if a worktree is stale and safe to prune
is_worktree_stale() {
    local branch="$1"
    local worktree_path="$2"

    # Determine main branch name
    local main_branch
    main_branch=$(git config --get init.defaultBranch 2>/dev/null || echo "main")

    # Try main, fallback to master if main doesn't exist
    if ! git show-ref --verify --quiet "refs/heads/$main_branch" 2>/dev/null; then
        main_branch="master"
    fi

    # Check if branch is merged into main/master
    if git branch --merged "$main_branch" 2>/dev/null | grep -q "^[* ]*$branch$"; then
        # Safety guardrail: Check for uncommitted changes
        cd "$worktree_path" 2>/dev/null || return 1
        if [[ -z "$(git status --porcelain 2>/dev/null)" ]]; then
            return 0  # Is stale and safe to prune
        fi
    fi

    return 1  # Not stale or not safe to prune
}

# Auto-prune stale worktrees (merged branches with no uncommitted changes)
auto_prune_stale_worktrees() {
    local project_name
    project_name=$(get_project_name)
    local pruned=0
    local space_freed=0

    # Get list of worktrees (skip main worktree)
    local main_worktree
    main_worktree=$(get_main_worktree)

    while IFS= read -r line; do
        # Match lines starting with "worktree" from git worktree list output
        if [[ "$line" =~ ^worktree ]]; then
            local wt_path="${line#worktree }"

            # Skip main worktree
            [[ "$wt_path" == "$main_worktree" ]] && continue

            # Get branch for this worktree
            local branch
            branch=$(git -C "$wt_path" branch --show-current 2>/dev/null)

            # Check if stale and prune
            if [[ -n "$branch" ]] && is_worktree_stale "$branch" "$wt_path"; then
                # Calculate size before removal (in KB)
                local size
                size=$(du -sk "$wt_path" 2>/dev/null | awk '{print $1}')

                # Remove worktree
                if git worktree remove --force "$wt_path" 2>/dev/null; then
                    pruned=$((pruned + 1))
                    space_freed=$((space_freed + size))

                    # Clean up empty parent directories
                    local parent_dir
                    parent_dir="$(dirname "$wt_path")"
                    if [[ -d "$parent_dir" ]] && [[ -z "$(ls -A "$parent_dir" 2>/dev/null)" ]]; then
                        rmdir "$parent_dir" 2>/dev/null
                    fi
                fi
            fi
        fi
    done < <(git worktree list --porcelain 2>/dev/null)

    # Report if anything was pruned
    if [[ $pruned -gt 0 ]]; then
        local space_mb=$((space_freed / 1024))
        echo "[Auto-pruned $pruned merged worktree(s): ${space_mb}MB freed]"
    fi
}

# Open or create worktree (called from fuzzy finder)
open_or_create_worktree() {
    local line="$1"

    # Strip ANSI color codes and extract branch name
    local branch
    branch=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^[✓ ]*//' | sed 's/ \[.*\]$//')

    if [[ -z "$branch" ]]; then
        error "No branch selected"
        return 1
    fi

    local worktree_path
    worktree_path=$(get_worktree_path "$branch")

    # If worktree exists, just open it
    if [[ -d "$worktree_path" ]]; then
        info "Opening existing worktree: $worktree_path"

        if command -v cursor &> /dev/null; then
            cursor "$worktree_path"
        else
            echo -e "${BLUE}cd $worktree_path${NC}"
        fi
    else
        # Create new worktree
        cmd_add "$branch"
    fi
}

# Interactive fuzzy finder mode
cmd_interactive() {
    check_git_repo
    check_fzf

    # Check for migration notice
    check_worktree_migration

    # Start async auto-prune if enabled
    if [[ "$(git config --get worktree.autoprune 2>/dev/null)" == "true" ]]; then
        # Fork to background, redirect output to temp log
        (auto_prune_stale_worktrees > /tmp/git-wt-prune-$$.log 2>&1) &
    fi

    # Export functions so they're available to fzf subshells
    export -f show_worktree_info
    export -f open_or_create_worktree
    export -f has_worktree
    export -f get_worktree_path
    export -f get_project_name
    export -f format_branch_line
    export -f generate_branch_list
    export -f error
    export -f success
    export -f info
    export -f warning
    export WORKTREE_BASE
    export RED
    export GREEN
    export YELLOW
    export BLUE
    export NC

    local script_path="$0"

    # Create a named pipe (FIFO) for async branch loading
    local fifo
    fifo=$(mktemp -u)
    mkfifo "$fifo"

    # Clean up FIFO on exit
    trap 'rm -f "$fifo"' EXIT

    # Background process to generate branches asynchronously
    (
        # First, output local branches immediately
        generate_branch_list "local-only"

        # Now fetch remote branches in background
        local current_branch
        current_branch=$(git branch --show-current 2>/dev/null || echo "")
        local branches=()

        # Get local branches first (for deduplication)
        while IFS= read -r branch; do
            branches+=("$branch|local")
        done < <(git branch --format='%(refname:short)' 2>/dev/null)

        # Now get remote-only branches
        while IFS= read -r branch; do
            local branch_name="${branch#origin/}"
            # Skip if this is HEAD or if we already have it as local
            # Check if branch already exists in array with "|local" suffix using literal string match
            if [[ "$branch_name" != "HEAD" ]] && ! [[ " ${branches[*]} " == *" $branch_name|local "* ]]; then
                format_branch_line "$branch_name" "remote" "$current_branch"
            fi
        done < <(git branch -r --format='%(refname:short)' 2>/dev/null | grep "^origin/")
    ) > "$fifo" &

    local bg_pid=$!

    # Launch fuzzy finder with the FIFO as input
    local result
    result=$(fzf \
        --ansi \
        --print-query \
        --preview "$script_path __preview {}" \
        --preview-window right:50% \
        --prompt "Select branch > " \
        --header "[Enter] Open/Create  [Esc] Cancel" \
        --border \
        --height 100% \
        --no-select-1 < "$fifo")

    # Wait for background process to finish
    wait $bg_pid 2>/dev/null

    # Handle selection - fzf with --print-query outputs query on first line, selection on second
    if [[ -n "$result" ]]; then
        local query
        query=$(echo "$result" | head -n 1)
        local selected
        selected=$(echo "$result" | sed -n '2p')

        echo ""
        # If user selected an item from the list, use that. Otherwise use the query (new branch name)
        if [[ -n "$selected" ]]; then
            open_or_create_worktree "$selected"
        elif [[ -n "$query" ]]; then
            open_or_create_worktree "$query"
        else
            info "Cancelled"
        fi
    else
        echo ""
        info "Cancelled"
    fi
}

# Add a new worktree
cmd_add() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "Usage: git-wt add <branch-name>"
        exit 1
    fi

    check_git_repo

    local project_name
    project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch_name"
    local main_worktree
    main_worktree=$(get_main_worktree)

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        error "Worktree already exists at $worktree_path"
        exit 1
    fi

    # Create worktree directory structure
    mkdir -p "$(dirname "$worktree_path")"

    # Fetch latest from remote to ensure we have up-to-date branch info
    info "Fetching latest from remote..."
    if git fetch origin 2>/dev/null; then
        success "Fetched latest changes from origin"
    else
        warning "Could not fetch from origin (might not have remote configured)"
    fi

    # Check if branch exists on remote
    local remote_branch_exists
    remote_branch_exists=$(git ls-remote --heads origin "$branch_name" 2>/dev/null)
    local local_branch_exists
    local_branch_exists=$(git show-ref --verify --quiet "refs/heads/$branch_name" && echo "yes" || echo "no")

    info "Creating worktree for branch '$branch_name'..."

    # Create the worktree based on what exists (check local first!)
    if [[ "$local_branch_exists" == "yes" ]]; then
        # Local branch exists - use it (most common case)
        if git worktree add "$worktree_path" "$branch_name" 2>/dev/null; then
            success "Worktree created from local branch '$branch_name'"
        else
            error "Failed to create worktree from local branch"
            exit 1
        fi
    elif [[ -n "$remote_branch_exists" ]]; then
        # Remote branch exists but no local - create local tracking remote
        if git worktree add --track -b "$branch_name" "$worktree_path" "origin/$branch_name" 2>/dev/null; then
            success "Worktree created from remote branch 'origin/$branch_name'"
        else
            error "Failed to create worktree from remote branch"
            exit 1
        fi
    else
        # Branch doesn't exist anywhere - create new branch
        if git worktree add "$worktree_path" -b "$branch_name" 2>/dev/null; then
            success "Worktree created with new branch '$branch_name'"
        else
            error "Failed to create worktree with new branch"
            exit 1
        fi
    fi

    # Symlink .env files
    symlink_env_files "$main_worktree" "$worktree_path"

    # Detect and run package manager
    local pkg_manager
    pkg_manager=$(detect_package_manager "$worktree_path")

    if [[ -n "$pkg_manager" ]]; then
        info "Detected package manager: $pkg_manager"
        info "Installing dependencies..."

        cd "$worktree_path" || exit 1

        case "$pkg_manager" in
            pnpm)
                if pnpm install; then
                    success "Dependencies installed successfully"
                else
                    warning "Failed to install dependencies"
                fi
                ;;
            yarn)
                if yarn install; then
                    success "Dependencies installed successfully"
                else
                    warning "Failed to install dependencies"
                fi
                ;;
            npm)
                if npm install; then
                    success "Dependencies installed successfully"
                else
                    warning "Failed to install dependencies"
                fi
                ;;
        esac
    fi

    echo ""
    success "Worktree ready!"

    # Open in Cursor
    if command -v cursor &> /dev/null; then
        info "Opening worktree in Cursor..."
        cursor "$worktree_path"
    else
        info "To switch to the new worktree, run:"
        echo -e "${BLUE}  cd $worktree_path${NC}"
    fi
}

# List all worktrees for current project
cmd_list() {
    check_git_repo

    # Check for migration notice
    check_worktree_migration

    local project_name
    project_name=$(get_project_name)
    local project_worktrees="$WORKTREE_BASE/$project_name"

    info "Worktrees for project '$project_name':"
    echo ""

    git worktree list | while IFS= read -r line; do
        local path
        path=$(echo "$line" | awk '{print $1}')
        local branch
        branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local main_marker=""

        if echo "$line" | grep -q "(bare)"; then
            branch="(bare)"
        fi

        # Check if this is the main worktree
        if [[ "$path" == "$(get_main_worktree)" ]]; then
            main_marker="${GREEN}[main]${NC} "
        fi

        # Highlight if path is under our managed worktrees
        if [[ "$path" == "$project_worktrees"* ]]; then
            echo -e "  ${GREEN}●${NC} $main_marker$branch"
            echo -e "    ${BLUE}$path${NC}"
        else
            echo -e "  ${YELLOW}●${NC} $main_marker$branch"
            echo -e "    ${BLUE}$path${NC}"
        fi
        echo ""
    done
}

# Remove a worktree
cmd_remove() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "Usage: git-wt remove <branch-name>"
        exit 1
    fi

    check_git_repo

    local project_name
    project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch_name"

    if [[ ! -d "$worktree_path" ]]; then
        error "Worktree not found at $worktree_path"
        exit 1
    fi

    info "Removing worktree at $worktree_path..."

    if git worktree remove "$worktree_path" --force; then
        success "Worktree removed successfully"

        # Clean up empty parent directories
        local parent_dir
        parent_dir="$(dirname "$worktree_path")"
        if [[ -d "$parent_dir" ]] && [[ -z "$(ls -A "$parent_dir")" ]]; then
            rmdir "$parent_dir"
            info "Cleaned up empty directory: $parent_dir"
        fi
    else
        error "Failed to remove worktree"
        exit 1
    fi
}

# Prune stale worktree references
cmd_prune() {
    check_git_repo

    info "Pruning stale worktree references..."

    if git worktree prune --verbose; then
        success "Pruning complete"
    else
        error "Failed to prune worktrees"
        exit 1
    fi
}

# Show current configuration
cmd_config() {
    info "Git Worktree Configuration"
    echo ""

    # Show current base path
    echo -e "${BLUE}Current worktree base path:${NC}"
    echo "  $WORKTREE_BASE"
    echo ""

    # Show source of configuration
    local local_config=$(git config --local --get worktree.basepath 2>/dev/null)
    local global_config=$(git config --global --get worktree.basepath 2>/dev/null)
    local env_var="$GIT_WT_BASE"

    echo -e "${BLUE}Configuration sources (in priority order):${NC}"

    if [[ -n "$local_config" ]]; then
        echo -e "  ${GREEN}✓${NC} Local git config:  $local_config ${GREEN}[active]${NC}"
    else
        echo -e "    Local git config:  ${YELLOW}(not set)${NC}"
    fi

    if [[ -n "$global_config" ]]; then
        if [[ -z "$local_config" ]]; then
            echo -e "  ${GREEN}✓${NC} Global git config: $global_config ${GREEN}[active]${NC}"
        else
            echo -e "    Global git config: $global_config ${YELLOW}(overridden by local)${NC}"
        fi
    else
        echo -e "    Global git config: ${YELLOW}(not set)${NC}"
    fi

    if [[ -n "$env_var" ]]; then
        if [[ -z "$local_config" ]] && [[ -z "$global_config" ]]; then
            echo -e "  ${GREEN}✓${NC} Environment var:   $env_var ${GREEN}[active]${NC}"
        else
            echo -e "    Environment var:   $env_var ${YELLOW}(overridden)${NC}"
        fi
    else
        echo -e "    Environment var:   ${YELLOW}(not set)${NC}"
    fi

    if [[ -z "$local_config" ]] && [[ -z "$global_config" ]] && [[ -z "$env_var" ]]; then
        echo -e "  ${GREEN}✓${NC} Default:           $HOME/Git/.worktrees ${GREEN}[active]${NC}"
    else
        echo -e "    Default:           $HOME/Git/.worktrees"
    fi

    echo ""

    # Show auto-prune status
    local autoprune=$(git config --get worktree.autoprune 2>/dev/null)
    echo -e "${BLUE}Auto-pruning:${NC}"
    if [[ "$autoprune" == "true" ]]; then
        echo -e "  ${GREEN}✓ Enabled${NC}"
    else
        echo -e "  ${YELLOW}✗ Disabled${NC}"
    fi

    echo ""
    info "To change configuration:"
    echo "  git config --global worktree.basepath <path>  # Set globally"
    echo "  git config --local worktree.basepath <path>   # Set for this repo"
    echo "  export GIT_WT_BASE=<path>                     # Set via environment"
}

# Show help
cmd_help() {
    cat << EOF
git-wt - Git worktree management tool

USAGE:
  git-wt [branch-name|options]

MODES:
  git-wt                Interactive fuzzy finder to browse and select branches
                        - Shows all local and remote branches
                        - Visual indicators for existing worktrees
                        - Preview pane with worktree details
                        - Press Enter to create or open worktree

  git-wt <branch-name>  Directly create or open worktree for specified branch
                        - Creates worktree at ${WORKTREE_BASE}/<project>/<branch>
                        - Symlinks all .env* files from main repo
                        - Detects and runs package manager install
                        - Opens in Cursor (if available)

OPTIONS:
  --list, -l               Show all worktrees for the current project
  --remove <branch>, -r    Remove a worktree
  --prune, -p              Remove stale worktree references
  --cleanup                Manually prune merged branch worktrees
  --enable-autoprune       Enable automatic pruning for this repo
  --disable-autoprune      Disable automatic pruning for this repo
  --config                 Show current configuration
  --help, -h               Show this help message

EXAMPLES:
  # Launch interactive fuzzy finder
  git-wt

  # Directly create/open a worktree
  git-wt feature/new-feature

  # List all worktrees
  git-wt --list

  # Remove a worktree
  git-wt --remove feature/old-feature

  # Clean up stale references
  git-wt --prune

  # Enable auto-pruning (removes merged branches automatically)
  git-wt --enable-autoprune

  # Manually cleanup merged branch worktrees
  git-wt --cleanup

  # Show current configuration
  git-wt --config

AUTO-PRUNING:
  When enabled, git-wt automatically removes worktrees for branches that have been
  merged into main/master. This happens in the background when running git-wt.

  Safety: Only removes worktrees with no uncommitted changes.

  Enable:  git-wt --enable-autoprune
  Disable: git-wt --disable-autoprune
  Manual:  git-wt --cleanup

LOCATION:
  All worktrees are stored in: ${WORKTREE_BASE}/<project-name>/<branch-name>

CONFIGURATION:
  You can customize the worktree storage location:

  # Set globally for all repositories
  git config --global worktree.basepath ~/custom/path

  # Set for current repository only
  git config --local worktree.basepath ~/custom/path

  # Or use environment variable
  export GIT_WT_BASE=~/custom/path

  Priority: local git config > global git config > environment variable > default

REQUIREMENTS:
  - fzf (for interactive mode): brew install fzf

EOF
}

# Main command dispatcher
main() {
    local command="${1:-}"

    # Handle flag-based commands
    case "$command" in
        __preview)
            # Internal command for fzf preview pane
            shift
            show_worktree_info "$@"
            ;;
        --list|-l|list|ls)
            cmd_list
            ;;
        --remove|-r|remove|rm)
            shift
            cmd_remove "$@"
            ;;
        --prune|-p|prune)
            cmd_prune
            ;;
        --enable-autoprune)
            git config worktree.autoprune true
            success "Auto-pruning enabled for this repository"
            info "Merged branches will be automatically cleaned up when running git-wt"
            ;;
        --disable-autoprune)
            git config --unset worktree.autoprune 2>/dev/null || true
            success "Auto-pruning disabled for this repository"
            ;;
        --cleanup)
            check_git_repo
            info "Checking for stale worktrees..."
            auto_prune_stale_worktrees
            ;;
        --config)
            cmd_config
            ;;
        --help|-h|help)
            cmd_help
            ;;
        "")
            # No arguments - launch interactive mode
            cmd_interactive
            ;;
        *)
            # Treat as branch name - direct mode
            open_or_create_worktree "$command"
            ;;
    esac
}

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
