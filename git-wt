#!/bin/bash

# Git worktree management script
# Stores worktrees in ~/Git/.worktrees/<project-name>/<branch-name>

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Base directory for all worktrees
WORKTREE_BASE="$HOME/Git/.worktrees"

# Print colored messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

success() {
    echo -e "${GREEN}$1${NC}"
}

info() {
    echo -e "${BLUE}$1${NC}"
}

warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not a git repository"
        exit 1
    fi
}

# Get the project name from git repo
get_project_name() {
    # Try to get from remote URL first
    local remote_url=$(git config --get remote.origin.url 2>/dev/null)

    if [[ -n "$remote_url" ]]; then
        # Extract project name from URL (handles both SSH and HTTPS)
        local project_name=$(echo "$remote_url" | sed -E 's/.*[:/]([^/]+)\/([^/]+)(\.git)?$/\2/')
    else
        # Fallback to directory name
        local project_name=$(basename "$(git rev-parse --show-toplevel)")
    fi

    echo "$project_name"
}

# Get the main worktree path
get_main_worktree() {
    git worktree list | head -n 1 | awk '{print $1}'
}

# Detect package manager
detect_package_manager() {
    local worktree_path="$1"

    if [[ -f "$worktree_path/pnpm-lock.yaml" ]]; then
        echo "pnpm"
    elif [[ -f "$worktree_path/yarn.lock" ]]; then
        echo "yarn"
    elif [[ -f "$worktree_path/package-lock.json" ]]; then
        echo "npm"
    else
        # Default to pnpm if no lock file found but package.json exists
        if [[ -f "$worktree_path/package.json" ]]; then
            echo "pnpm"
        else
            echo ""
        fi
    fi
}

# Symlink env files
symlink_env_files() {
    local source_dir="$1"
    local target_dir="$2"

    local env_files=$(find "$source_dir" -maxdepth 1 -type f \( -name ".env" -o -name ".env.*" \) 2>/dev/null)

    if [[ -z "$env_files" ]]; then
        info "No .env files found to symlink"
        return
    fi

    info "Symlinking .env files..."
    while IFS= read -r env_file; do
        if [[ -n "$env_file" ]]; then
            local filename=$(basename "$env_file")
            local target="$target_dir/$filename"

            if [[ -e "$target" ]]; then
                warning "Skipping $filename (already exists in worktree)"
            else
                ln -s "$env_file" "$target"
                success "  Linked $filename"
            fi
        fi
    done <<< "$env_files"
}

# Add a new worktree
cmd_add() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "Usage: git-wt add <branch-name>"
        exit 1
    fi

    check_git_repo

    local project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch_name"
    local main_worktree=$(get_main_worktree)

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        error "Worktree already exists at $worktree_path"
        exit 1
    fi

    # Create worktree directory structure
    mkdir -p "$(dirname "$worktree_path")"

    # Fetch latest from remote to ensure we have up-to-date branch info
    info "Fetching latest from remote..."
    if git fetch origin 2>/dev/null; then
        success "Fetched latest changes from origin"
    else
        warning "Could not fetch from origin (might not have remote configured)"
    fi

    # Check if branch exists on remote
    local remote_branch_exists=$(git ls-remote --heads origin "$branch_name" 2>/dev/null)
    local local_branch_exists=$(git show-ref --verify --quiet "refs/heads/$branch_name" && echo "yes" || echo "no")

    info "Creating worktree for branch '$branch_name'..."

    # Create the worktree based on what exists (check local first!)
    if [[ "$local_branch_exists" == "yes" ]]; then
        # Local branch exists - use it (most common case)
        if git worktree add "$worktree_path" "$branch_name" 2>/dev/null; then
            success "Worktree created from local branch '$branch_name'"
        else
            error "Failed to create worktree from local branch"
            exit 1
        fi
    elif [[ -n "$remote_branch_exists" ]]; then
        # Remote branch exists but no local - create local tracking remote
        if git worktree add --track -b "$branch_name" "$worktree_path" "origin/$branch_name" 2>/dev/null; then
            success "Worktree created from remote branch 'origin/$branch_name'"
        else
            error "Failed to create worktree from remote branch"
            exit 1
        fi
    else
        # Branch doesn't exist anywhere - create new branch
        if git worktree add "$worktree_path" -b "$branch_name" 2>/dev/null; then
            success "Worktree created with new branch '$branch_name'"
        else
            error "Failed to create worktree with new branch"
            exit 1
        fi
    fi

    # Symlink .env files
    symlink_env_files "$main_worktree" "$worktree_path"

    # Detect and run package manager
    local pkg_manager=$(detect_package_manager "$worktree_path")

    if [[ -n "$pkg_manager" ]]; then
        info "Detected package manager: $pkg_manager"
        info "Installing dependencies..."

        cd "$worktree_path" || exit 1

        case "$pkg_manager" in
            pnpm)
                pnpm install
                ;;
            yarn)
                yarn install
                ;;
            npm)
                npm install
                ;;
        esac

        if [[ $? -eq 0 ]]; then
            success "Dependencies installed successfully"
        else
            warning "Failed to install dependencies"
        fi
    fi

    echo ""
    success "Worktree ready!"

    # Open in Cursor
    if command -v cursor &> /dev/null; then
        info "Opening worktree in Cursor..."
        cursor "$worktree_path"
    else
        info "To switch to the new worktree, run:"
        echo -e "${BLUE}  cd $worktree_path${NC}"
    fi
}

# List all worktrees for current project
cmd_list() {
    check_git_repo

    local project_name=$(get_project_name)
    local project_worktrees="$WORKTREE_BASE/$project_name"

    info "Worktrees for project '$project_name':"
    echo ""

    git worktree list | while IFS= read -r line; do
        local path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local main_marker=""

        if echo "$line" | grep -q "(bare)"; then
            branch="(bare)"
        fi

        # Check if this is the main worktree
        if [[ "$path" == "$(get_main_worktree)" ]]; then
            main_marker="${GREEN}[main]${NC} "
        fi

        # Highlight if path is under our managed worktrees
        if [[ "$path" == "$project_worktrees"* ]]; then
            echo -e "  ${GREEN}●${NC} $main_marker$branch"
            echo -e "    ${BLUE}$path${NC}"
        else
            echo -e "  ${YELLOW}●${NC} $main_marker$branch"
            echo -e "    ${BLUE}$path${NC}"
        fi
        echo ""
    done
}

# Remove a worktree
cmd_remove() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "Usage: git-wt remove <branch-name>"
        exit 1
    fi

    check_git_repo

    local project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch_name"

    if [[ ! -d "$worktree_path" ]]; then
        error "Worktree not found at $worktree_path"
        exit 1
    fi

    info "Removing worktree at $worktree_path..."

    if git worktree remove "$worktree_path" --force; then
        success "Worktree removed successfully"

        # Clean up empty parent directories
        local parent_dir="$(dirname "$worktree_path")"
        if [[ -d "$parent_dir" ]] && [[ -z "$(ls -A "$parent_dir")" ]]; then
            rmdir "$parent_dir"
            info "Cleaned up empty directory: $parent_dir"
        fi
    else
        error "Failed to remove worktree"
        exit 1
    fi
}

# Prune stale worktree references
cmd_prune() {
    check_git_repo

    info "Pruning stale worktree references..."

    if git worktree prune --verbose; then
        success "Pruning complete"
    else
        error "Failed to prune worktrees"
        exit 1
    fi
}

# Show help
cmd_help() {
    cat << 'EOF'
git-wt - Git worktree management tool

USAGE:
  git-wt <command> [arguments]

COMMANDS:
  add <branch-name>     Create a new worktree for the specified branch
                        - Creates worktree at ~/Git/.worktrees/<project>/<branch>
                        - Symlinks all .env* files from main repo
                        - Detects and runs package manager install

  list                  Show all worktrees for the current project

  remove <branch-name>  Remove a worktree

  prune                 Remove stale worktree references

  help                  Show this help message

EXAMPLES:
  # Create a new worktree for feature branch
  git-wt add feature/new-feature

  # List all worktrees
  git-wt list

  # Remove a worktree
  git-wt remove feature/old-feature

  # Clean up stale references
  git-wt prune

LOCATION:
  All worktrees are stored in: ~/Git/.worktrees/<project-name>/<branch-name>

EOF
}

# Main command dispatcher
main() {
    local command="${1:-help}"

    case "$command" in
        add)
            shift
            cmd_add "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        remove|rm)
            shift
            cmd_remove "$@"
            ;;
        prune)
            cmd_prune
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
