#!/bin/bash

# Git worktree management script
# Stores worktrees in ~/Git/.worktrees/<project-name>/<branch-name>

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Base directory for all worktrees
WORKTREE_BASE="$HOME/Git/.worktrees"

# Print colored messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

success() {
    echo -e "${GREEN}$1${NC}"
}

info() {
    echo -e "${BLUE}$1${NC}"
}

warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not a git repository"
        exit 1
    fi
}

# Get the project name from git repo
get_project_name() {
    # Try to get from remote URL first
    local remote_url=$(git config --get remote.origin.url 2>/dev/null)

    if [[ -n "$remote_url" ]]; then
        # Extract project name from URL (handles both SSH and HTTPS)
        local project_name=$(echo "$remote_url" | sed -E 's/.*[:/]([^/]+)\/([^/]+)(\.git)?$/\2/')
    else
        # Fallback to directory name
        local project_name=$(basename "$(git rev-parse --show-toplevel)")
    fi

    echo "$project_name"
}

# Get the main worktree path
get_main_worktree() {
    git worktree list | head -n 1 | awk '{print $1}'
}

# Detect package manager
detect_package_manager() {
    local worktree_path="$1"

    if [[ -f "$worktree_path/pnpm-lock.yaml" ]]; then
        echo "pnpm"
    elif [[ -f "$worktree_path/yarn.lock" ]]; then
        echo "yarn"
    elif [[ -f "$worktree_path/package-lock.json" ]]; then
        echo "npm"
    else
        # Default to pnpm if no lock file found but package.json exists
        if [[ -f "$worktree_path/package.json" ]]; then
            echo "pnpm"
        else
            echo ""
        fi
    fi
}

# Symlink env files
symlink_env_files() {
    local source_dir="$1"
    local target_dir="$2"

    local env_files=$(find "$source_dir" -maxdepth 1 -type f \( -name ".env" -o -name ".env.*" \) 2>/dev/null)

    if [[ -z "$env_files" ]]; then
        info "No .env files found to symlink"
        return
    fi

    info "Symlinking .env files..."
    while IFS= read -r env_file; do
        if [[ -n "$env_file" ]]; then
            local filename=$(basename "$env_file")
            local target="$target_dir/$filename"

            if [[ -e "$target" ]]; then
                warning "Skipping $filename (already exists in worktree)"
            else
                ln -s "$env_file" "$target"
                success "  Linked $filename"
            fi
        fi
    done <<< "$env_files"
}

# Check if fzf is installed
check_fzf() {
    if ! command -v fzf &> /dev/null; then
        error "fzf is required for interactive mode"
        echo ""
        info "Install fzf:"
        echo "  macOS:  brew install fzf"
        echo "  Linux:  apt install fzf  (or your package manager)"
        echo ""
        info "Alternatively, use direct mode:"
        echo "  git-wt <branch-name>"
        echo "  git-wt --list"
        exit 1
    fi
}

# Check if branch has a worktree
has_worktree() {
    local branch="$1"
    local project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch"
    [[ -d "$worktree_path" ]]
}

# Get worktree path for branch
get_worktree_path() {
    local branch="$1"
    local project_name=$(get_project_name)
    echo "$WORKTREE_BASE/$project_name/$branch"
}

# Generate branch list with indicators for fuzzy finder
# Parameters:
#   $1: mode - "local-only" to only show local branches, "all" to show all branches
generate_branch_list() {
    local mode="${1:-all}"
    local current_branch=$(git branch --show-current 2>/dev/null || echo "")

    # Get branches based on mode
    local branches=()

    # Local branches
    while IFS= read -r branch; do
        branches+=("$branch|local")
    done < <(git branch --format='%(refname:short)' 2>/dev/null)

    # Remote branches (excluding HEAD) - only if mode is "all"
    if [[ "$mode" == "all" ]]; then
        while IFS= read -r branch; do
            local branch_name="${branch#origin/}"
            # Skip if this is HEAD or if we already have it as local
            if [[ "$branch_name" != "HEAD" ]] && ! [[ " ${branches[@]} " =~ " ${branch_name}|local " ]]; then
                branches+=("$branch_name|remote")
            fi
        done < <(git branch -r --format='%(refname:short)' 2>/dev/null | grep "^origin/")
    fi

    # Sort and format branches with indicators
    local formatted_branches=()

    # First add current branch
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" == "$current_branch" ]]; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    # Then add branches with worktrees
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" != "$current_branch" ]] && has_worktree "$branch"; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    # Then add other local branches
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" != "$current_branch" ]] && ! has_worktree "$branch" && [[ "$type" == "local" ]]; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    # Finally add remote-only branches
    for branch_info in "${branches[@]}"; do
        local branch="${branch_info%|*}"
        local type="${branch_info#*|}"

        if [[ "$branch" != "$current_branch" ]] && ! has_worktree "$branch" && [[ "$type" == "remote" ]]; then
            formatted_branches+=("$(format_branch_line "$branch" "$type" "$current_branch")")
        fi
    done

    printf '%s\n' "${formatted_branches[@]}"
}

# Format a single branch line with indicators
format_branch_line() {
    local branch="$1"
    local type="$2"
    local current_branch="$3"

    local indicator=""
    local suffix=""

    # Add worktree indicator
    if has_worktree "$branch"; then
        indicator="\033[0;32m✓\033[0m "  # Green checkmark
    else
        indicator="  "
    fi

    # Add status suffix
    if [[ "$branch" == "$current_branch" ]]; then
        suffix=" \033[0;33m[current]\033[0m"  # Yellow
    elif [[ "$type" == "remote" ]]; then
        suffix=" \033[0;36m[remote only]\033[0m"  # Cyan
    fi

    echo -e "${indicator}${branch}${suffix}"
}

# Show worktree info for preview pane
show_worktree_info() {
    local line="$1"

    # Strip ANSI color codes and extract branch name
    local branch=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^[✓ ]*//' | sed 's/ \[.*\]$//')

    if [[ -z "$branch" ]]; then
        echo "No branch selected"
        return
    fi

    echo "Branch: $branch"
    echo ""

    # Check if worktree exists
    local worktree_path=$(get_worktree_path "$branch")

    if [[ -d "$worktree_path" ]]; then
        echo "Worktree: $worktree_path"

        # Git status
        cd "$worktree_path" 2>/dev/null || return
        local status=$(git status --porcelain 2>/dev/null)
        if [[ -z "$status" ]]; then
            echo "Status: Clean ✓"
        else
            echo "Status: Has uncommitted changes"
        fi

        # Last modified time
        local last_modified=$(find "$worktree_path" -type f -not -path "*/node_modules/*" -not -path "*/.git/*" -exec stat -f "%m %N" {} \; 2>/dev/null | sort -rn | head -1 | awk '{print $1}')
        if [[ -n "$last_modified" ]]; then
            local mod_date=$(date -r "$last_modified" "+%Y-%m-%d %H:%M" 2>/dev/null)
            echo "Last modified: $mod_date"
        fi

        # Directory size
        local total_size=$(du -sh "$worktree_path" 2>/dev/null | awk '{print $1}')
        echo "Size: $total_size"

        if [[ -d "$worktree_path/node_modules" ]]; then
            local nm_size=$(du -sh "$worktree_path/node_modules" 2>/dev/null | awk '{print $1}')
            echo "  (node_modules: $nm_size)"
        fi

        echo ""
        echo "Recent commits:"
        git log --oneline --color=always -n 3 2>/dev/null | sed 's/^/  /'

    else
        echo "Worktree: Not created"
        echo ""

        # Check if branch exists locally or remotely
        if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            echo "Branch type: Local"
            echo ""
            echo "Recent commits:"
            git log --oneline --color=always -n 3 "$branch" 2>/dev/null | sed 's/^/  /' || echo "  No commits yet"
        elif git ls-remote --heads origin "$branch" 2>/dev/null | grep -q "$branch"; then
            echo "Branch type: Remote only (origin/$branch)"
            echo ""
            echo "Recent commits:"
            git log --oneline --color=always -n 3 "origin/$branch" 2>/dev/null | sed 's/^/  /' || echo "  Unable to fetch commits"
        else
            echo "Branch type: New (will be created from current HEAD)"
        fi
    fi
}

# Open or create worktree (called from fuzzy finder)
open_or_create_worktree() {
    local line="$1"

    # Strip ANSI color codes and extract branch name
    local branch=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^[✓ ]*//' | sed 's/ \[.*\]$//')

    if [[ -z "$branch" ]]; then
        error "No branch selected"
        return 1
    fi

    local worktree_path=$(get_worktree_path "$branch")

    # If worktree exists, just open it
    if [[ -d "$worktree_path" ]]; then
        info "Opening existing worktree: $worktree_path"

        if command -v cursor &> /dev/null; then
            cursor "$worktree_path"
        else
            echo -e "${BLUE}cd $worktree_path${NC}"
        fi
    else
        # Create new worktree
        cmd_add "$branch"
    fi
}

# Interactive fuzzy finder mode
cmd_interactive() {
    check_git_repo
    check_fzf

    # Export functions so they're available to fzf subshells
    export -f show_worktree_info
    export -f open_or_create_worktree
    export -f has_worktree
    export -f get_worktree_path
    export -f get_project_name
    export -f format_branch_line
    export -f generate_branch_list
    export -f error
    export -f success
    export -f info
    export -f warning
    export WORKTREE_BASE
    export RED
    export GREEN
    export YELLOW
    export BLUE
    export NC

    local script_path="$0"

    # Create a named pipe (FIFO) for async branch loading
    local fifo=$(mktemp -u)
    mkfifo "$fifo"

    # Clean up FIFO on exit
    trap "rm -f '$fifo'" EXIT

    # Background process to generate branches asynchronously
    (
        # First, output local branches immediately
        generate_branch_list "local-only"

        # Add a loading indicator for remote branches
        echo -e "  \033[0;90m[Loading remote branches...]\033[0m"

        # Now fetch remote branches in background
        local current_branch=$(git branch --show-current 2>/dev/null || echo "")
        local branches=()

        # Get local branches first (for deduplication)
        while IFS= read -r branch; do
            branches+=("$branch|local")
        done < <(git branch --format='%(refname:short)' 2>/dev/null)

        # Now get remote-only branches
        while IFS= read -r branch; do
            local branch_name="${branch#origin/}"
            # Skip if this is HEAD or if we already have it as local
            if [[ "$branch_name" != "HEAD" ]] && ! [[ " ${branches[@]} " =~ " ${branch_name}|local " ]]; then
                format_branch_line "$branch_name" "remote" "$current_branch"
            fi
        done < <(git branch -r --format='%(refname:short)' 2>/dev/null | grep "^origin/")
    ) > "$fifo" &

    local bg_pid=$!

    # Launch fuzzy finder with the FIFO as input
    # Filter out the loading indicator line from selection
    local selected=$(cat "$fifo" | fzf \
        --ansi \
        --preview "$script_path __preview {}" \
        --preview-window right:50% \
        --prompt "Select branch > " \
        --header "[Enter] Open/Create  [Esc] Cancel" \
        --border \
        --height 100% \
        --no-select-1)

    # Wait for background process to finish
    wait $bg_pid 2>/dev/null

    # Filter out loading indicator if it was selected (shouldn't happen, but just in case)
    if [[ "$selected" =~ "Loading remote branches" ]]; then
        echo ""
        info "Cancelled"
        return
    fi

    # Handle selection
    if [[ -n "$selected" ]]; then
        echo ""
        open_or_create_worktree "$selected"
    else
        echo ""
        info "Cancelled"
    fi
}

# Add a new worktree
cmd_add() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "Usage: git-wt add <branch-name>"
        exit 1
    fi

    check_git_repo

    local project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch_name"
    local main_worktree=$(get_main_worktree)

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        error "Worktree already exists at $worktree_path"
        exit 1
    fi

    # Create worktree directory structure
    mkdir -p "$(dirname "$worktree_path")"

    # Fetch latest from remote to ensure we have up-to-date branch info
    info "Fetching latest from remote..."
    if git fetch origin 2>/dev/null; then
        success "Fetched latest changes from origin"
    else
        warning "Could not fetch from origin (might not have remote configured)"
    fi

    # Check if branch exists on remote
    local remote_branch_exists=$(git ls-remote --heads origin "$branch_name" 2>/dev/null)
    local local_branch_exists=$(git show-ref --verify --quiet "refs/heads/$branch_name" && echo "yes" || echo "no")

    info "Creating worktree for branch '$branch_name'..."

    # Create the worktree based on what exists (check local first!)
    if [[ "$local_branch_exists" == "yes" ]]; then
        # Local branch exists - use it (most common case)
        if git worktree add "$worktree_path" "$branch_name" 2>/dev/null; then
            success "Worktree created from local branch '$branch_name'"
        else
            error "Failed to create worktree from local branch"
            exit 1
        fi
    elif [[ -n "$remote_branch_exists" ]]; then
        # Remote branch exists but no local - create local tracking remote
        if git worktree add --track -b "$branch_name" "$worktree_path" "origin/$branch_name" 2>/dev/null; then
            success "Worktree created from remote branch 'origin/$branch_name'"
        else
            error "Failed to create worktree from remote branch"
            exit 1
        fi
    else
        # Branch doesn't exist anywhere - create new branch
        if git worktree add "$worktree_path" -b "$branch_name" 2>/dev/null; then
            success "Worktree created with new branch '$branch_name'"
        else
            error "Failed to create worktree with new branch"
            exit 1
        fi
    fi

    # Symlink .env files
    symlink_env_files "$main_worktree" "$worktree_path"

    # Detect and run package manager
    local pkg_manager=$(detect_package_manager "$worktree_path")

    if [[ -n "$pkg_manager" ]]; then
        info "Detected package manager: $pkg_manager"
        info "Installing dependencies..."

        cd "$worktree_path" || exit 1

        case "$pkg_manager" in
            pnpm)
                pnpm install
                ;;
            yarn)
                yarn install
                ;;
            npm)
                npm install
                ;;
        esac

        if [[ $? -eq 0 ]]; then
            success "Dependencies installed successfully"
        else
            warning "Failed to install dependencies"
        fi
    fi

    echo ""
    success "Worktree ready!"

    # Open in Cursor
    if command -v cursor &> /dev/null; then
        info "Opening worktree in Cursor..."
        cursor "$worktree_path"
    else
        info "To switch to the new worktree, run:"
        echo -e "${BLUE}  cd $worktree_path${NC}"
    fi
}

# List all worktrees for current project
cmd_list() {
    check_git_repo

    local project_name=$(get_project_name)
    local project_worktrees="$WORKTREE_BASE/$project_name"

    info "Worktrees for project '$project_name':"
    echo ""

    git worktree list | while IFS= read -r line; do
        local path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local main_marker=""

        if echo "$line" | grep -q "(bare)"; then
            branch="(bare)"
        fi

        # Check if this is the main worktree
        if [[ "$path" == "$(get_main_worktree)" ]]; then
            main_marker="${GREEN}[main]${NC} "
        fi

        # Highlight if path is under our managed worktrees
        if [[ "$path" == "$project_worktrees"* ]]; then
            echo -e "  ${GREEN}●${NC} $main_marker$branch"
            echo -e "    ${BLUE}$path${NC}"
        else
            echo -e "  ${YELLOW}●${NC} $main_marker$branch"
            echo -e "    ${BLUE}$path${NC}"
        fi
        echo ""
    done
}

# Remove a worktree
cmd_remove() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "Usage: git-wt remove <branch-name>"
        exit 1
    fi

    check_git_repo

    local project_name=$(get_project_name)
    local worktree_path="$WORKTREE_BASE/$project_name/$branch_name"

    if [[ ! -d "$worktree_path" ]]; then
        error "Worktree not found at $worktree_path"
        exit 1
    fi

    info "Removing worktree at $worktree_path..."

    if git worktree remove "$worktree_path" --force; then
        success "Worktree removed successfully"

        # Clean up empty parent directories
        local parent_dir="$(dirname "$worktree_path")"
        if [[ -d "$parent_dir" ]] && [[ -z "$(ls -A "$parent_dir")" ]]; then
            rmdir "$parent_dir"
            info "Cleaned up empty directory: $parent_dir"
        fi
    else
        error "Failed to remove worktree"
        exit 1
    fi
}

# Prune stale worktree references
cmd_prune() {
    check_git_repo

    info "Pruning stale worktree references..."

    if git worktree prune --verbose; then
        success "Pruning complete"
    else
        error "Failed to prune worktrees"
        exit 1
    fi
}

# Show help
cmd_help() {
    cat << 'EOF'
git-wt - Git worktree management tool

USAGE:
  git-wt [branch-name|options]

MODES:
  git-wt                Interactive fuzzy finder to browse and select branches
                        - Shows all local and remote branches
                        - Visual indicators for existing worktrees
                        - Preview pane with worktree details
                        - Press Enter to create or open worktree

  git-wt <branch-name>  Directly create or open worktree for specified branch
                        - Creates worktree at ~/Git/.worktrees/<project>/<branch>
                        - Symlinks all .env* files from main repo
                        - Detects and runs package manager install
                        - Opens in Cursor (if available)

OPTIONS:
  --list, -l            Show all worktrees for the current project
  --remove <branch>, -r Remove a worktree
  --prune, -p           Remove stale worktree references
  --help, -h            Show this help message

EXAMPLES:
  # Launch interactive fuzzy finder
  git-wt

  # Directly create/open a worktree
  git-wt feature/new-feature

  # List all worktrees
  git-wt --list

  # Remove a worktree
  git-wt --remove feature/old-feature

  # Clean up stale references
  git-wt --prune

LOCATION:
  All worktrees are stored in: ~/Git/.worktrees/<project-name>/<branch-name>

REQUIREMENTS:
  - fzf (for interactive mode): brew install fzf

EOF
}

# Main command dispatcher
main() {
    local command="${1:-}"

    # Handle flag-based commands
    case "$command" in
        __preview)
            # Internal command for fzf preview pane
            shift
            show_worktree_info "$@"
            ;;
        --list|-l|list|ls)
            cmd_list
            ;;
        --remove|-r|remove|rm)
            shift
            cmd_remove "$@"
            ;;
        --prune|-p|prune)
            cmd_prune
            ;;
        --help|-h|help)
            cmd_help
            ;;
        "")
            # No arguments - launch interactive mode
            cmd_interactive
            ;;
        *)
            # Treat as branch name - direct mode
            cmd_add "$command"
            ;;
    esac
}

main "$@"
