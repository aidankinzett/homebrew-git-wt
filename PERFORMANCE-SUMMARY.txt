================================================================================
                  WORKTREE LOADING PERFORMANCE ANALYSIS
                              QUICK SUMMARY
================================================================================

MAIN BOTTLENECK:
  git worktree list --porcelain called 500+ times per fuzzy finder session
  
LOCATION: lib/fuzzy-finder.sh, Lines 52-90
SEVERITY: Critical
TIME IMPACT: 8-12 seconds (5-10 seconds wasted on redundant calls)

================================================================================
                           TOP 3 BOTTLENECKS
================================================================================

BOTTLENECK 1: Redundant has_worktree() Calls
────────────────────────────────────────────────────────────────────────────
  File:     lib/fuzzy-finder.sh, Lines 52-90
  Function: generate_branch_list()
  Problem:  4 loops over branches, each calling has_worktree()
  Impact:   20 branches = 80 git commands, 20 remote branches = 120+ commands
  Command:  git worktree list --porcelain
  Time:     5-10 seconds wasted
  Fix:      Cache worktree list, use O(1) lookups instead
  Code:     Replace 4 loops with single pass + hash map


BOTTLENECK 2: Heavy File I/O in Preview Pane
────────────────────────────────────────────────────────────────────────────
  File:     lib/fuzzy-finder.sh, Lines 154-177
  Function: show_worktree_info()
  Problem:  find + stat scans entire worktree tree for last modified time
  Impact:   1GB worktree with 1000+ files = 2-5 seconds per preview
  Commands: find, stat, du -sh (3 slow operations per preview)
  Time:     2-5 seconds per preview pane display
  Fix:      Option A: Disable in preview pane
           Option B: Cache results in .git/git-wt-cache/
  Code:     Remove lines 158-178 OR implement caching


BOTTLENECK 3: Git Branch Merged Check
────────────────────────────────────────────────────────────────────────────
  File:     lib/worktree-ops.sh, Lines 57-84
  Function: is_worktree_stale()
  Problem:  git branch --merged called per worktree during auto-prune
  Impact:   30 stale worktrees = 30 redundant calls to git branch --merged
  Command:  git branch --merged
  Time:     2-3 seconds during auto-prune
  Fix:      Cache merged branch list, use for all staleness checks
  Code:     Store output of git branch --merged once


================================================================================
                        GIT COMMANDS BY FREQUENCY
================================================================================

Rank  Command                                  Called From            Count
────  ───────────────────────────────────────  ─────────────────────  ──────
  1.  git worktree list --porcelain           has_worktree()         500+
  2.  git branch --format                     generate_branch_list   3-4x
  3.  git branch -r --format                  generate_branch_list   2-3x
  4.  git branch --show-current               Multiple functions     3-5x
  5.  git branch --merged                     is_worktree_stale      Per WT
  6.  git -C ... branch --show-current        auto_prune             Per WT
  7.  git -C ... status --porcelain           Multiple functions     3-5x
  8.  git show-ref --verify --quiet           show_worktree_info     Per WT
  9.  git ls-remote --heads                   show_worktree_info     Per WT
 10.  git log --oneline -n 3                  show_worktree_info     Per WT

================================================================================
                         PERFORMANCE TARGETS
================================================================================

Current State           →        After Caching        Target
─────────────────────────────────────────────────────────────────────────────
Fuzzy finder:  8-12 sec         1-2 sec             < 2 sec       (87% gain)
Preview pane:  2-5 sec          < 100ms             < 500ms       (95% gain)
Auto-prune:    5-8 sec          < 1 sec             < 2 sec       (87% gain)
Git commands:  500+             5-10                < 20          (98% gain)

================================================================================
                      PHASE 1 IMPLEMENTATION (30 MIN)
================================================================================

Step 1: Add Cache Variables to lib/worktree-ops.sh
  _worktree_list_cache=""
  _worktree_list_cache_valid=0

Step 2: Create Cache Functions in lib/worktree-ops.sh
  get_worktree_list_cached()
    - Returns cached list if valid
    - Runs git worktree list --porcelain if not
    - Sets _worktree_list_cache_valid=1
  
  invalidate_worktree_cache()
    - Clears _worktree_list_cache
    - Sets _worktree_list_cache_valid=0

Step 3: Update Functions
  has_worktree()
    OLD: git worktree list --porcelain | grep ...
    NEW: get_worktree_list_cached | grep ...
  
  get_worktree_path()
    OLD: git worktree list --porcelain | grep ...
    NEW: get_worktree_list_cached | grep ...

Step 4: Add Invalidation Calls
  commands.sh:194          (cmd_remove)           → invalidate_worktree_cache
  fuzzy-finder.sh:290      (delete_worktree)      → invalidate_worktree_cache
  fuzzy-finder.sh:349      (delete_worktree_int)  → invalidate_worktree_cache
  fuzzy-finder.sh:411      (recreate_worktree)    → invalidate_worktree_cache
  worktree-ops.sh:116      (auto_prune)           → invalidate_worktree_cache

RESULT: 80-90% faster fuzzy finder + 50% faster preview pane

================================================================================
                          FILES TO MODIFY
================================================================================

PRIORITY  FILE                    CHANGES                              TIME
────────  ──────────────────────  ────────────────────────────────    ──────
P0        lib/worktree-ops.sh    Add cache + update functions         30 min
P0        lib/fuzzy-finder.sh    Use cache, fix loop redundancy       30 min
P0        commands.sh            Add invalidation calls               10 min
P1        lib/git-utils.sh       Cache get_main_worktree()            15 min
P2        test/caching.bats      Add unit tests                       30 min

Total Implementation Time: ~115 minutes (with testing)

================================================================================
                    ANALYSIS DOCUMENTS LOCATION
================================================================================

PERFORMANCE-ANALYSIS-INDEX.md
  └─ Overview of all documents, how to use them, quick reference

worktree-loading-performance-analysis.md (13KB)
  └─ Deep dive into current architecture, specific function analysis

git-commands-reference.md (9KB)
  └─ Master list of all 21 git commands, frequency, impact

caching-strategy-recommendations.md (17KB)
  └─ Detailed implementation plan with code examples, rollout strategy

All files in: /home/user/homebrew-git-wt/docs/plans/

================================================================================
                              WORST CASES
================================================================================

Scenario A: Large Repo with Many Branches
  - 200 local branches
  - 300 remote branches  
  - 50 worktrees
  
  Current: 502 × git worktree list --porcelain = 30+ seconds
  Cached:  1 × git worktree list --porcelain + O(1) lookups = <2 seconds

Scenario B: Auto-Prune with Stale Worktrees
  - 100 total worktrees
  - 30 candidates for pruning
  
  Current: 30 × git branch --merged + 30 × git status = 5+ seconds
  Cached:  1 × git branch --merged + 30 × git status = <1 second

================================================================================
                          NEXT STEPS
================================================================================

1. Read PERFORMANCE-ANALYSIS-INDEX.md for complete context
2. Read worktree-loading-performance-analysis.md for detailed analysis
3. Review caching-strategy-recommendations.md for implementation details
4. Create Phase 1 implementation plan
5. Measure baseline performance (before caching)
6. Implement Phase 1 caching
7. Measure improvement (target: 80-90% faster)
8. Move to Phase 2 (branch list caching)
9. Add comprehensive tests
10. Update documentation

================================================================================
Generated: 2025-11-18
